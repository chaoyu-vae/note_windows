#### iota: 为go语言中的常量数目计数器，只能在常量表达式中使用，遇到<span style="color:red">const</span>会自动被设置成0，常用于枚举类型

#### 字符串：

- 字符串内部是使用<span style="color:red">UTF-8编码</span>

- 反引号中的转义字符会被原样输出

- 拼接字符串： +/

  ```go
  fmt.Sprintf
  stings.Split()  #分割
  strings.Contains() #是否包含
  strings.HasPrefix(), strings.HasSuffix()   #前后缀判断
  strings.Index(), strings.LastIndex()     #字串出现的位置
  strings.Jion()    #Jion操作
  ```

- 字符种类

  - uint8类型/byte型
  - rune类型，即UTF-8类型

- #### 数组

  - ```go
    [n]*T #指针数组
    *[n]T #数组指针
    var arr0 [5]int = {1,2,3,4,5}
    var arr1 = [5]int{1,2,3,4,5}
    var arr2 = ...int{1,2,3,4,5}
    var arr3 = ...int{3: 2, 4:5}  #初始化数组，下标为3对应的值为2，4对应的值为5
    ```

  - <span style="color: red">值拷贝会导致性能问题，建议只用切片</span>

#### 切片：

- 切片是引用类型

- cap和len函数在切片中是不一样的。cap是切片的容量，是切片所能达到的最大长度

- 可通过make函数创建，

  ```go
  var slice := make([]int, 1, 3)  #参数依次为切片的长度和容量
  ```

- 可使用append内置函数，追加切片内容，在尾部追加内容返回新的切片

  ```
  var a := []int{1,2}
  var d := append(a, 7)
  var b := []int{3,4}
  var c:= append(a, b...)
  ```

- 超出原 slice.cap 限制，就会重新分配底层数组，即便原数组并未填满。通常以2倍的容量重新分配数组

- <span style="color:red">注意： 在大批量添加数据时，建议一次性分配足够大的空间，以减少内存分配和数据复制开销。或初始化足够长的 len 属性，改用索引号进行操作。及时释放不再使用的 slice 对象，避免持有过期数组，造成 GC 无法回收。</span>

#### 指针：

- go中的指针是安全指针，不能进行偏移和运算
- 内置函数new(type),该函数会返回一个类型的指针，并且该指针对应的值为该类型的零值
- Go中声明变量后，需要为其分配内存，否则会引发panic。

#### 方法：

- 针对于某一特定类型变量的函数，这种特定的变量被称之为：接受者
- 值类型的接受者，在运行代码时会复制一份值，修改的也只是副本

#### 结构体:

- Go语言中没有类，使用结构体代替
- 继承：通过使用匿名结构体实现。
- 结构体标签(Tag)
  - 表示结构体的元数据，可通过反射的方式读取出来
  - 在结构体字段的后面定义，由一对反引号包裹，如`key1:"value1" key2:"value2"`

#### 延迟调用：

- 当一个函数被延迟调用后，其不会立即执行而是被推入协程维护的一个延迟调用堆栈中

